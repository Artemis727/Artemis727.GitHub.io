[{"title":"Data Science R Basic","url":"/2023/02/09/Data-Science-R-Basic/","content":"Words &amp; Expressions\nin a nested way 嵌套\nconcatenate 连接 c() -&gt; all items in ‘()’ to a vector\n\n\nWhy use ‘[[’ instead of ‘[’ to access variables?\\We extract the population like this:\np &lt;- murders$population\n\nIf you instead try to access a column with just one bracket,\nmurders[&quot;population&quot;]\n\n&#x3D;&#x3D;R returns a subset of the original data frame containing just this column. This new object will be of class data.frame rather than a vector.&#x3D;&#x3D; To access the column itself you need to use either the $ accessor or the double square brackets [[:\nmurders[[&quot;population&quot;]]\n\nR- sorting functions\nsort()\n# sort()排序，排序结果不可逆转# 默认是升序# decreasing为TRUE，表示降序# decreasing为FALSE，表示升序#排序后并不会修改原对象的值#示例如下：&gt; a &lt;- c(3,9,16,6,7,4,22,5,10,13)&gt; #sort()默认为从小到大（升序）排序，等同于decreasing=FALSE&gt; sort(a) [1]  3  4  5  6  7  9 10 13 16 22&gt; sort(a,decreasing = F) [1]  3  4  5  6  7  9 10 13 16 22&gt; #decreasing=TRUE,为从大到小（降序）排序&gt; sort(a,decreasing = T) [1] 22 16 13 10  9  7  6  5  4  3#排序并不会修改原对象的值，a仍为原来未排序的a&gt; a [1]  3  9 16  6  7  4 22  5 10 13\n\n\n\nrank()\n用法：rank(a)函数说明：指出当前向量中各元素大小的排名，默认升序函数还有其他的参数：rank(x &#x3D; data, na.last &#x3D; TRUE)x 表示待排序的向量na.last 表示是否排序时是否将NA放在最后面，默认忽略NA\n&gt; a &lt;- c(3,9,16,6,7,4,22,5,10,13)&gt; order(a) [1]  1  6  8  4  5  2  9 10  3  7#说明：在向量a中，3是第一小的数，位置下标为1；4是第二小的数，位置下标为6；最大的数是22，位置下标为7#a[order(a)] 等同于sort(a)&gt; a[order(a)]  [1]  3  4  5  6  7  9 10 13 16 22\n\n\n\norder()\n说明：返回的值表示位置，默认是升序，依次对应的是向量的最小值、次小值、第三小值…最大值\n用法：order(a), a为要排序的向量order(… &#x3D; data, na.last &#x3D; TRUE,decreasing &#x3D; TRUE)… 表示待排序向量na.last 表示时候将NA值放在最后面（默认排序忽略NA）decreasing 表示是否按照降序排序，默认升序。\n&gt; a [1]  3  9 16  6  7  4 22  5 10 13&gt; sort(a) [1]  3  4  5  6  7  9 10 13 16 22&gt; rank(a) [1]  1  6  9  4  5  2 10  3  7  8 #说明：向量a中的第一个数为3，是最小的，故排名为1；第二个数是9，是第六小的数，排名为6\n\n\n\n比较\n&gt; a &lt;- c(3,9,16,6,7,4,22,5,10,13)&gt; a [1]  3  9 16  6  7  4 22  5 10 13&gt; sort(a) #将a**从小到大排序并列出** [1]  3  4  5  6  7  9 10 13 16 22&gt; order(a) #返回从小到大的数的**位置下标**，a[order(a)]=sort(a) [1]  1  6  8  4  5  2  9 10  3  7&gt; rank(a) #返回a中**每个数的排名（从小到大）** [1]  1  6  9  4  5  2 10  3  7  8&gt; a [1]  3  9 16  6  7  4 22  5 10 13#注意：经过sort()、order()、rank()排序后，a不改变\n\norder和rank的区别在于一个返回的是index，一个是rank，index不一定是数字。\n\n\n","categories":["刷题笔记"],"tags":["R"]},{"title":"HousePricing","url":"/2023/02/23/HousePricing/","content":"Comprehensive data exploration with python | House Pricingknowledge\n偏度(skewness)和峰度(kurtosis）\n\n\nskewness 衡量数据分布的非对称程度\n正态分布 skewness &#x3D; 0\n右偏分布 skewness &gt; 0\n左偏分布 skewness &lt; 0\n\n\n\n\n\nkurtosis 表示概率密度曲线的峰值高低（峰的尖度）\n\n正态分布（&#x3D; 3）\n厚尾（&gt; 3）最低\n瘦尾（&lt; 3）最尖\n\n\n\n\n","categories":["刷题笔记"],"tags":["Python"]},{"title":"How is Hadley Wickham able to contribute so much to R, particularly in the form of packages?","url":"/2023/02/08/How-is-Hadley-Wickham-able-to-contribute-so-much-to-R-particularly-in-the-form-of-packages/","content":"How is Hadley Wickham able to contribute so much to R, particularly in the form of packages?\nDavid Robinson:\nFrom following Hadley’s work, it seems to me that along with being an exceptional programmer and data scientist, and having the advantage of developing R packages as part of his job, Hadley follows a few strategies that serve as useful wisdom for all developers:\n\nHe writes packages that make himself more productive. Three of Hadley’s popular packages, devtools, Roxygen2, and testthat, make it very easy to (respectively) develop, document and test R packages. He recognized that the time spent to create and maintain those was small compared to the time it would save him (and others!) in developing future packages. This extends beyond those package development tools: packages like stringr and lubridate are designed to make working with strings and dates easier. This also extends beyond his own packages: he takes advantage of packages like Rcpp (http://www.rcpp.org/) that make writing R C++ extensions fast and intuitive.\nHe takes full advantage of social coding. He’s a prolific GitHub user (hadley (Hadley Wickham)), which makes it efficient to receive and respond to bug reports and feature requests, and to collaborate with others (for instance, with Romain Francois on dplyr).\nHe works to simplify his packages rather than complicate them. In his announcement of the tidyr package (Introducing tidyr) he notes that “Just as reshape2 did less than reshape, tidyr does less than reshape2.” When packages are simpler (doing a few things well instead of hundreds of things poorly), they’re easier to develop and maintain.\n\n**Hadley Wickham: **\nI like David’s answer, but here are a few more thoughts from a personal perspective ;)\n\nWriting. I have worked really hard to build a solid writing habit - &#x3D;&#x3D;I try and write for 60-90 minutes every morning. It’s the first thing I do after I get out of bed.&#x3D;&#x3D; I think writing is really helpful to me for a few reasons. First, &#x3D;&#x3D;I often use my writing as a reference&#x3D;&#x3D; - I don’t program in C++ every day, so I’m constantly referring to @Rcpp every time I do. Writing also makes me aware of gaps in my knowledge and my tools, and filling in those gaps tends to make me more efficient at tackling new problems.\nReading. I read a lot. I follow about 300 blogs, and keep a pretty close eye on the R tags on Twitter and Stack Overflow. I don’t read most things deeply - &#x3D;&#x3D;the majority of content I only briefly skim. But this wide exposure helps me keep up with changes in technology, interesting new programming languages, and what others are doing with data.&#x3D;&#x3D; It’s also helpful that if when you’re tackling a new problem you can recognise the basic name - then googling for it will suggest possible solutions. If you don’t know the name of a problem, it’s very hard to research it.\nChunking. Context-switching is expensive, so if I worked on many packages at the same time, I’d never get anything done. Instead, at any point in time, most of my packages are lying fallow, steadily accumulating issues and ideas for new feature. Once a critical mass has accumulated, I’ll spend a couple of days on the package.\n\nFinally, it’s hard to over-emphasise the impact that working full-time on R makes. Since I’ve left Rice, I now spend well over 90% of my work time thinking about and programming in R. This has a compounding effect because as I built better tools (cognitive and computational) it becomes even easier to build new tools. I can create a new package in seconds, and I have many techniques on-hand (in-brain) for solving new problems.\n","categories":["Quora"]},{"title":"SQL-刷题笔记","url":"/2023/02/07/SQL%20%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","content":"1. 查询列列查询、多列查询、限制返回数量、in、like、聚合函数。\n# 查询所有列SELECT * FROM user_profile# 查询多列SELECT device_id, gender, age, university FROM user_profile# 查询结果去重SELECT DISTINCT university FROM user_profile# 查询结果限制返回行数SELECT device_id FROM user_profile LIMIT 2# 查询后重命名SELECT device_id FROM user_profile AS user_infos_example LIMIT 2# 否定查询select device_id, gender, age, universityfrom user_profilewhere not university = &#x27;复旦大学&#x27;# 过滤空值select device_id, gender, age, universityfrom user_profilewhere not age is null# inselect device_id, gender, age, university, gpa from user_profilewhere university in (&#x27;北京大学&#x27;, &#x27;复旦大学&#x27;, &#x27;山东大学&#x27;)# likeselect device_id, age, universityfrom user_profilewhere university like &#x27;%北京%&#x27;# max() min()select max(gpa)from user_praofilewhere university = &#x27;复旦大学&#x27;# avg() count()select count(gender) as male_num, avg(gpa) as avg_gpafrom user_profilewhere gender = &#x27;male&#x27;# havingselect university, avg(question_cnt) avg_question_cnt, avg(answer_cnt) avg_answer_cntfrom user_profilegroup by universityhaving avg_question_cnt &lt; 5 or avg_answer_cnt &lt; 20# 生成新字段后不能用where要用having\n\n\n\n2. 涉及到多个表的情况select university, (count(q.question_id)/count(distinct(q.device_id))) avg_answer_cntfrom user_profile ujoin question_practice_detail qon u.device_id = q.device_idgroup by universityorder by university asc\n\nselect u.university, q.difficult_level, count(qp.question_id)/count(distinct qp.device_id) avg_answer_cntfrom user_profile u, question_practice_detail qp, question_detail qwhere u.university = &#x27;山东大学&#x27; and u.device_id = qp.device_id and q.question_id = qp.question_idgroup by u.university, difficult_levelorder by avg_answer_cnt\n\n\n\nSQL25 查找山东大学或者性别为男生的信息题目：现在运营想要分别查看学校为山东大学或者性别为男性的用户的device_id、gender、age和gpa数据，请取出相应结果，结果不去重。\n示例：user_profile\n\n\n\nid\ndevice_id\ngender\nage\nuniversity\ngpa\nactive_days_within_30\nquestion_cnt\nanswer_cnt\n\n\n\n1\n2138\nmale\n21\n北京大学\n3.4\n7\n2\n12\n\n\n2\n3214\nmale\n\n复旦大学\n4\n15\n5\n25\n\n\n3\n6543\nfemale\n20\n北京大学\n3.2\n12\n3\n30\n\n\n4\n2315\nfemale\n23\n浙江大学\n3.6\n5\n1\n2\n\n\n5\n5432\nmale\n25\n山东大学\n3.8\n20\n15\n70\n\n\n6\n2131\nmale\n28\n山东大学\n3.3\n15\n7\n13\n\n\n7\n4321\nmale\n26\n复旦大学\n3.6\n9\n6\n52\n\n\n根据示例，你的查询应返回以下结果（注意输出的顺序，先输出学校为山东大学再输出性别为男生的信息）：\n\n\n\ndevice_id\ngender\nage\ngpa\n\n\n\n5432\nmale\n25\n3.8\n\n\n2131\nmale\n28\n3.3\n\n\n2138\nmale\n21\n3.4\n\n\n3214\nmale\nNone\n4\n\n\n5432\nmale\n25\n3.8\n\n\n2131\nmale\n28\n3.3\n\n\n4321\nmale\n28\n3.6\n\n\nselect device_id, gender, age, gpafrom user_profilewhere university = &#x27;山东大学&#x27;union all select device_id, gender, age, gpafrom user_profilewhere gender = &#x27;male&#x27;\n\n\n\n3. ifSQL26 计算25岁以上和以下的用户数量题目：现在运营想要将用户划分为25岁以下和25岁及以上两个年龄段，分别查看这两个年龄段用户数量\n本题注意：age为null 也记为 25岁以下\n示例：user_profile\n\n\n\nid\ndevice_id\ngender\nage\nuniversity\ngpa\nactive_days_within_30\nquestion_cnt\nanswer_cnt\n\n\n\n1\n2138\nmale\n21\n北京大学\n3.4\n7\n2\n12\n\n\n2\n3214\nmale\n\n复旦大学\n4\n15\n5\n25\n\n\n3\n6543\nfemale\n20\n北京大学\n3.2\n12\n3\n30\n\n\n4\n2315\nfemale\n23\n浙江大学\n3.6\n5\n1\n2\n\n\n5\n5432\nmale\n25\n山东大学\n3.8\n20\n15\n70\n\n\n6\n2131\nmale\n28\n山东大学\n3.3\n15\n7\n13\n\n\n7\n4321\nmale\n26\n复旦大学\n3.6\n9\n6\n52\n\n\n根据示例，你的查询应返回以下结果：\n\n\n\nage_cut\nnumber\n\n\n\n25岁以下\n4\n\n\n25岁及以上\n3\n\n\nselect age_cut, count(device_id) numberfrom(select if(age &gt;= 25, &#x27;25岁及以上&#x27;, &#x27;25岁以下&#x27;) as age_cut, device_id from user_profile) t1group by age_cut\n\n\n\n4. caseSQL27 查看不同年龄段的用户明细题目：现在运营想要将用户划分为20岁以下，20-24岁，25岁及以上三个年龄段，分别查看不同年龄段用户的明细情况，请取出相应数据。（注：若年龄为空请返回其他。）\n示例：user_profile\n\n\n\nid\ndevice_id\ngender\nage\nuniversity\ngpa\nactive_days_within_30\nquestion_cnt\nanswer_cnt\n\n\n\n1\n2138\nmale\n21\n北京大学\n3.4\n7\n2\n12\n\n\n2\n3214\nmale\n\n复旦大学\n4\n15\n5\n25\n\n\n3\n6543\nfemale\n20\n北京大学\n3.2\n12\n3\n30\n\n\n4\n2315\nfemale\n23\n浙江大学\n3.6\n5\n1\n2\n\n\n5\n5432\nmale\n25\n山东大学\n3.8\n20\n15\n70\n\n\n6\n2131\nmale\n28\n山东大学\n3.3\n15\n7\n13\n\n\n7\n4321\nmale\n26\n复旦大学\n3.6\n9\n6\n52\n\n\n根据示例，你的查询应返回以下结果：\n\n\n\ndevice_id\ngender\nage_cut\n\n\n\n2138\nmale\n20-24岁\n\n\n3214\nmale\n其他\n\n\n6543\nfemale\n20-24岁\n\n\n2315\nfemale\n20-24岁\n\n\n5432\nmale\n25岁及以上\n\n\n2131\nmale\n25岁及以上\n\n\n4321\nmale\n25岁及以上\n\n\nselect device_id, gender, case    when age &lt; 20 then &#x27;20岁以下&#x27;    when age &lt; 25 then &#x27;20-24岁&#x27;    when age &gt;= 25 then &#x27;25岁及以上&#x27;    else &#x27;其他&#x27;end age_cutfrom user_profile\n\n\n\n5. day()\nday()\n\nmonth()\n\nyear()\n\n\n6. 用户留存率计算SQL-计算用户次日留存率.md\n7. 字符串相关SQL-字符串相关.md\n","categories":["刷题笔记"],"tags":["SQL"]},{"title":"SQL-计算用户留存率","url":"/2023/02/07/SQL-%E8%AE%A1%E7%AE%97%E7%94%A8%E6%88%B7%E6%AC%A1%E6%97%A5%E7%95%99%E5%AD%98%E7%8E%87/","content":"计算用户次日留存率如果只是计算用户的次日留存率，那么使用date_sub()函数就够了：\nselect avg(if(b.device_id is not null, 1, 0)) as avg_retfrom(    select distinct device_id, date    from question_practice_detail) aleft join(    select distinct device_id, date_sub(date, interval 1 day) as date    from question_practice_detail) bon a.device_id = b.device_id and a.date = b.date\n\n\ndate_sub() 函数：\n\nSELECT DATE_SUB(‘2010-08-12’, INTERVAL 3 DAY) AS NewDate \n结果： 2010-08-09\n\nSELECT DATE_SUB(‘2010-08-12’, INTERVAL ‘3-2’ YEAR_MONTH) AS NewDate \n结果： 2007-06-12\n\nSELECT DATE_SUB(‘2011-09-14 2:44:36’, INTERVAL ‘2:26’ HOUR_MINUTE) AS NewDate \n结果： 2011-09-14 00:18:36\n\n\n\n\n基于SQL的留存率计算\n转自知乎：基于SQL的留存率计算\n\n一、什么是留存率互联网行业里，留存率是用于反映网站、互联网应用或网络游戏的运营情况的统计指标，其具体含义为在统计周期（周&#x2F;月）内，每日活跃用户数在第N日仍启动该App的用户数占比的平均值。其中N通常取2、3、7、14、30，分别对应次日留存率、三日留存率、周留存率、半月留存率和月留存率。\n留存率常用于反映用户粘性，当N取值越大、留存率越高时，用户粘性越高。\n二、留存率的计算\n留存率 &#x3D; 登陆用户数&#x2F;新增用户数 * 100%\n\n新增用户数：在当前时间段新注册（或新访问）的用户数；\n\n登录用户数：在统计的时间段至少登录过一次的用户数；\n\n次日留存率：在次日至少登录过一次的用户数&#x2F;当天新增的用户数；\n\n❗️3日留存率：在往后3天内至少登录过一次的用户数&#x2F;当天新增的用户数；\n\n❗️7日留存率：在往后7天内至少登录过一次的用户数&#x2F;当天新增的用户数；\n\n❗️15日留存数：当天新增的用户数，在往后7天内至少登录过一次的用户，在往后第8天到第14天内至少再登陆过一次的用户数\n➡️ 3日和7日，至少登陆过一次；15日，7天为一段，在每段内至少登录一次！\n\n\nSQL中计算用户的留存率\n新增用户数\n\n由于数据过大，这截取时间2017.11.26~2017.12.03为例。\n首先计算分母，这里有的算法是用新增用户数，有的算法是用活跃用户数。\n⚠️注意：新增用户数与活跃用户数并不相等，活跃用户数包含新增用户数。活跃用户数，当天的访问人数，也就是UV。\n-- 每位用户的最早登录日期SELECT 用户ID, MIN(日期) AS 最早登录日期FROM userbehaviorWHERE 日期 &gt; &#x27;2017-11-25&#x27;AND 日期 &lt; &#x27;2017-12-04&#x27;GROUP BY 用户ID\n\n\n再从上表中计算出每天的新增人数，❗️算新增人数用的日期是最早登录日期！\nSELECT 最早登录日期 AS 日期, COUNT(DISTINCT 用户ID) AS 新增人数FROM(SELECT 用户ID, MIN(日期) AS 最早登录日期     FROM userbehavior     WHERE 日期 &gt; &#x27;2017-11-25&#x27; AND 日期 &lt; &#x27;2017-12-04&#x27;     GROUP BY 用户ID) AS fGROUP BY 最早登录日期\n\n\n以下是活跃用户数的算法，二者确实数值上并不相等。❗️算每日活跃用户数用的日期就是当天的日期！\n-- 每天活跃用户数=UV 访客数SELECT 日期, COUNT(DISTINCT 用户ID) AS 活跃用户数FROM userbehaviorwhere 日期 &gt;&#x27;2017-11-25&#x27; AND 日期 &lt; &#x27;2017-12-04&#x27;GROUP BY 日期\n\n\n抽取7天的活跃用户数。\n\n次日留存的用户数\n\n\n次日的时间间隔为1，涉及到时间间隔采用自联结。\n\nSELECT a.用户ID, a.`日期` AS atime, b.`日期` AS btimeFROM userbehavior AS a LEFT JOIN userbehavior AS bON a.`用户ID` = b.`用户ID`WHERE a.`日期` &gt; &#x27;2017-11-25&#x27; AND a.`日期` &lt; &#x27;2017-12-04&#x27;\n\n\n将上表存为视图C，\nCREATE VIEW C(用户ID, atime, btime)ASSELECT a.用户ID, a.`日期`, b.`日期` from userbehavior AS a LEFT JOIN userbehavior AS bON a.`用户ID`=b.`用户ID`WHERE a.`日期`&gt;&#x27;2017-11-25&#x27;AND a.`日期` &lt; &#x27;2017-12-04&#x27;;\n\n\n计算时间间隔用timestampdiff函数\n\nSELECT `用户ID`, TIMESTAMPDIFF(DAY, atime, btime)AS 时间间隔FROM (  SELECT a.用户ID, a.日期 as atime, b.日期 as btime  FROM userbehavior as a LEFT JOIN userbehavior as b  ON a.用户ID=b.`用户ID`  WHERE a.`日期`&gt;&#x27;2017-11-25&#x27;AND a.`日期` &lt; &#x27;2017-12-04&#x27;) AS c-- 这里直接设置为表c\n\n\n得到了用户的时间间隔\n3.用case语句筛选出时间间隔为1的数据，并且进行计数\nSELECT *, COUNT(DISTINCT case when 时间间隔 = 1 then `用户ID`\t\t\tELSE NULL\t\t\tEND)AS 次日留存数FROM( SELECT `用户ID`,TIMESTAMPDIFF(DAY,atime,btime)AS 时间间隔\t\t\t FROM (\t\t\t\tSELECT a.用户ID,a.日期 as atime,b.日期 as btime\t\t\t\tFROM userbehavior as a LEFT JOIN userbehavior as b\t\t\t\tON a.用户ID=b.`用户ID`\t\t\t\tWHERE a.`日期`&gt;&#x27;2017-11-25&#x27;AND a.`日期` &lt; &#x27;2017-12-04&#x27;\t\t\t\t) AS c\t\t\t)AS d\n\n\n次日留存率\n\n次日留存率&#x3D;次日留存用户数&#x2F;当日活跃用户数\nSELECT *,COUNT(DISTINCT case when 时间间隔 = 1 then `用户ID`\t\t\tELSE NULL\t\t\tEND) AS 次日留存数/COUNT(DISTINCT 用户ID) AS 次日留存率FROM( SELECT `用户ID`,TIMESTAMPDIFF(DAY,atime,btime)AS 时间间隔\t\t\t FROM (\t\t\t\tSELECT a.用户ID,a.日期 as atime,b.日期 as btime\t\t\t\tFROM userbehavior as a LEFT JOIN userbehavior as b\t\t\t\tON a.用户ID=b.`用户ID`\t\t\t\tWHERE a.`日期`&gt;&#x27;2017-11-25&#x27;AND a.`日期` &lt; &#x27;2017-12-04&#x27;\t\t\t\t) AS c\t\t\t)AS d\n\n\n\n三、三日以及N日留存的计算只需要修改时间间隔&#x3D;N即可。\nSELECT 日期,COUNT(DISTINCT 用户ID AS 活跃用户数,COUNT(DISTINCT case when 时间间隔=1 then `用户ID`\t\t\tELSE NULL\t\t\tEND) AS 次日留存数/COUNT(DISTINCT 用户ID) AS 次日留存率COUNT(DISTINCT case when 时间间隔=3 then `用户ID`\t\t\tELSE NULL\t\t\tEND) AS 次日留存数/COUNT(DISTINCT 用户ID) AS 三日留存率COUNT(DISTINCT case when 时间间隔=7 then `用户ID`\t\t\tELSE NULL\t\t\tEND) AS 次日留存数/COUNT(DISTINCT 用户ID) AS 七日留存率FROM( SELECT `用户ID`,TIMESTAMPDIFF(DAY,atime,btime)AS 时间间隔\t\t\t FROM (\t\t\t\tSELECT a.用户ID,a.日期 as atime,b.日期 as btime\t\t\t\tFROM userbehavior as a LEFT JOIN 每日新增用户数表 as b\t\t\t\tON a.用户ID=b.`用户ID`\t\t\t\tWHERE a.`日期`&gt;&#x27;2017-11-25&#x27;AND a.`日期` &lt; &#x27;2017-12-04&#x27;\t\t\t\t) AS c\t\t\t)AS d","categories":["刷题笔记"],"tags":["SQL"]},{"title":"Hello World","url":"/2023/02/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"SQL-字符串相关","url":"/2023/02/07/SQL-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/","content":"SQL30 统计每种性别的人数描述题目：现在运营举办了一场比赛，收到了一些参赛申请，表数据记录形式如下所示，现在运营想要统计每个性别的用户分别有多少参赛者，请取出相应结果\n示例：user_submit\n\n\n\ndevice_id\nprofile\nblog_url\n\n\n\n2138\n180cm,75kg,27,male\nhttp:&#x2F;url&#x2F;bigboy777\n\n\n3214\n165cm,45kg,26,female\nhttp:&#x2F;url&#x2F;kittycc\n\n\n6543\n178cm,65kg,25,male\nhttp:&#x2F;url&#x2F;tiger\n\n\n4321\n171cm,55kg,23,female\nhttp:&#x2F;url&#x2F;uhksd\n\n\n2131\n168cm,45kg,22,female\nhttp:&#x2F;urlsydney\n\n\n根据示例，你的查询应返回以下结果：\n\n\n\ngender\nnumber\n\n\n\nmale\n2\n\n\nfemale\n3\n\n\n\nselect substring_index(profile, &#x27;,&#x27;, -1) as gender, count(device_id)from user_submitgroup by gender\n\n\n\nSQL31 提取博客URL中的用户名描述题目：对于申请参与比赛的用户，blog_url字段中url字符后的字符串为用户个人博客的用户名，现在运营想要把用户的个人博客用户字段提取出单独记录为一个新的字段，请取出所需数据。\n示例：user_submit\n\n\n\ndevice_id\nprofile\nblog_url\n\n\n\n2138\n180cm,75kg,27,male\nhttp:&#x2F;ur&#x2F;bisdgboy777\n\n\n3214\n165cm,45kg,26,female\nhttp:&#x2F;url&#x2F;dkittycc\n\n\n6543\n178cm,65kg,25,male\nhttp:&#x2F;ur&#x2F;tigaer\n\n\n4321\n171 cm,55kg,23,female\nhttp:&#x2F;url&#x2F;uhksd\n\n\n2131\n168cm,45kg,22,female\nhttp:&#x2F;url&#x2F;sydney\n\n\n根据示例，你的查询应返回以下结果：\n\n\n\ndevice_id\nuser_name\n\n\n\n2138\nbisdgboy777\n\n\n3214\ndkittycc\n\n\n6543\ntigaer\n\n\n4321\nuhsksd\n\n\n2131\nsydney\n\n\n\n提取某个字符一般有四种做法：\ntrim()\ntrim() 是直接更改相同格式的一列，删除这一列内容中的统一部分，然后重命名：\nselect device_id, trim(&#x27;http:/url/&#x27; from blog_url) as user_namefrom user_submit\n\n​\t\n\nsubstring_index()\nsubstring_index() 是将字符串切割，1表示保留字符串的左边👈，-1表示保留字符串的右边👉：\nselect device_id, substring_index(blog_url, &#x27;/url/&#x27;, -1) as user_namefrom user_submit\n\n还有一个用法是计数：\nSUBSTRING_INDEX(str,delim,count) 返回从字符串str分隔符 delim 在计数发生前的子字符串。如果计数是正的，则返回一切到最终定界符(从左边算起)的左侧。如果count是负数，则返回一切最终定界符(从右边算起)的右侧。SUBSTRING_INDEX() 搜寻在delim时进行区分大小写的匹配。\nSELECT SUBSTRING_INDEX(&#x27;www.somewebsite.com&#x27;,&#x27;.&#x27;,2);\n\nOutput: &#39;www.somewebsite&#39;\n\nsubstr()\nsubstr() 是用具体位置（数字）来表示从哪开始截取的，参数里还包括截取的长度：\nselect device_id, substr(blog_url, 11, length(blog_url)-10) as user_namefrom user_submit\n\n\n\nreplace()\nreplace() 就是替换函数：\nsleect device_id, replace(blog_url, &#x27;http:/url/&#x27;, &#x27;&#x27;) as user_namefrom user_submit\n\nSQL32 截取出年龄描述题目：现在运营举办了一场比赛，收到了一些参赛申请，表数据记录形式如下所示，现在运营想要统计每个年龄的用户分别有多少参赛者，请取出相应结果\n示例：user_submit\n\n\n\ndevice_id\nprofile\nblog_url\n\n\n\n2138\n180cm,75kg,27,male\nhttp:&#x2F;ur&#x2F;bigboy777\n\n\n3214\n165cm,45kg,26,female\nhttp:&#x2F;url&#x2F;kittycc\n\n\n6543\n178cm,65kg,25,male\nhttp:&#x2F;url&#x2F;tiger\n\n\n4321\n171cm,55kg,23,female\nhttp:&#x2F;url&#x2F;uhksd\n\n\n2131\n168cm,45kg,22,female\nhttp:&#x2F;url&#x2F;sydney\n\n\n根据示例，你的查询应返回以下结果：\n\n\n\nage\nnumber\n\n\n\n27\n1\n\n\n26\n1\n\n\n25\n1\n\n\n23\n1\n\n\n22\n1\n\n\nselect substring_index(substring_index(profile, &#x27;,&#x27;, -2), &#x27;,&#x27;, 1) as age, count(device_id)from user_submitgroup by age\n\n","categories":["刷题笔记"],"tags":["SQL","字符串"]}]